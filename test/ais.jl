import Random

function test_ais_mle()

    function p_true_given_true(theta)
        @assert theta >= 0.
        @assert theta <= 1.
        0.5 + 0.4 * theta # theta ranges from 0 to 1
    end

    @gen function foo(theta::Float64)
        z = @trace(bernoulli(0.2), :z)
        p = p_true_given_true(theta)
        x = @trace(bernoulli(z ? p : 1-p), :x)
    end

    x = true

    # p(x = 1)
    lml = log(0.2 * p_true_given_true(1.) + 0.8 * (1 - p_true_given_true(1.)))

    # ais()
    Random.seed!(1)
    args_seq = map((theta) -> (theta,), range(0., stop=1., length=Int(1e6)))
    argdiffs = (UnknownChange(),)
    mh_fwd, mh_rev = t -> mh(t, select(:z))[1], t -> mh(t, select(:z))[1]
    @time (actual, _, _) = ais(foo, choicemap((:x, true)), args_seq, argdiffs, mh_fwd)
    expected = lml
    @test isapprox(actual, expected, atol=1e-2)

    # test the combinator
    output_addrs = select(:z)
    ais_gf_args = (
        foo, choicemap((:x, true)), args_seq, argdiffs, mh_fwd, mh_rev, output_addrs)

    # get_score(ais_trace), as generated by simulate()
    @time ais_trace = simulate(AISGF(), ais_gf_args)
    z = ais_trace[:z]
    model_trace, = generate(foo, (1.,), choicemap((:z, z), (:x, x)))
    actual = get_score(ais_trace)
    expected = get_score(model_trace) - lml
    @test isapprox(actual, expected, atol=1e-2)

    # get_score(ais_trace), as generated by generate()
    z = false
    @time ais_trace, = generate(AISGF(), ais_gf_args, choicemap((:z, z)))
    ais_score = get_score(ais_trace)
    model_trace, = generate(foo, (1.,), choicemap((:z, z), (:x, x)))
    actual = get_score(model_trace) - ais_score
    expected = lml
    @test isapprox(actual, expected, atol=1e-2)

end

@testset "AIS" begin
    test_ais_mle()
end
